export interface GeneratedResult {
    specContent: string;
    fixtureContent: string;
    pages: { [className: string]: string };
    testData: any;
}

export class GeneratorAgent {

    private getPageClassName(url: string, fallback: string = 'BasePage'): string {
        if (!url || url === 'about:blank') return fallback;
        try {
            const urlObj = new URL(url);
            let pathName = urlObj.pathname;
            if (pathName === '/' || pathName === '') {
                let hostParts = urlObj.hostname.split('.');
                if (hostParts[0] === 'www') hostParts.shift();
                let name = hostParts[0];
                return name.charAt(0).toUpperCase() + name.slice(1) + 'Page';
            } else {
                const segments = pathName.split('/').filter(s => s.length > 0);
                let lastSegment = segments[segments.length - 1];
                lastSegment = lastSegment.replace(/[^a-zA-Z0-9]/g, '');
                if (!lastSegment) return fallback;
                return lastSegment.charAt(0).toUpperCase() + lastSegment.slice(1) + 'Page';
            }
        } catch {
            return fallback;
        }
    }

    async generatePlaywrightSpec(featureName: string, events: any[]): Promise<GeneratedResult> {
        const config = (await import('../core/config')).Config;
        const { LocatorMap } = await import('../core/locator-map');

        // Ensure map is loaded
        await LocatorMap.load(config.DataIdValuePath);

        let stepCount = 1;

        let specImports = `import { test, expect } from '@playwright/test';\nimport { LocatorMap } from '../core/locator-map';\n`;
        let specBody = "";

        let currentUrl = config.UrlPath;
        let currentPageClass = this.getPageClassName(currentUrl);

        if (events.length > 0) {
            let firstRealNav = events.find(ev => (ev.type === 'navigation' || ev.type === 'url-change') && ev.url !== 'about:blank');
            let initialUrl = firstRealNav ? firstRealNav.url : config.UrlPath;
            specBody += `
    await test.step('Initial Navigation', async () => {
        await page.goto('${initialUrl}');
        await page.waitForLoadState('networkidle');
    });`;
        }

        for (const e of events) {
            if (e.type === 'navigation' || e.type === 'url-change') {
                if (e.url === 'about:blank') continue; // Avoid playwright timeouts on blank page transitions

                currentUrl = e.url;

                if (e.type === 'navigation') {
                    specBody += `
    await test.step('Navigate to ${e.url}', async () => {
        await page.goto('${e.url}');
        await page.waitForLoadState('networkidle');
    });`;
                } else {
                    specBody += `
    await test.step('URL changed to ${e.url}', async () => {
        await expect(page).toHaveURL('${e.url}');
        await page.waitForLoadState('networkidle');
    });`;
                }
            } else if (e.type === 'manual') {
                let selector = e.selector || '';
                const match = selector.match(/^\{(.+)\}$/);
                if (match) {
                    selector = match[1];
                }

                specBody += `
    await test.step('Manual Step: ${e.value}', async () => {
        const locator = page.locator('${selector}');
        await expect(locator).toBeVisible({ timeout: 15000 });
        await locator.click(); // Defaulting manual step to click. User should edit this block.
    });`;
            } else {
                const cleanFeature = featureName.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
                let key = e.id;

                if (!key) {
                    key = `${cleanFeature}_${e.type}_${stepCount++}`;
                }

                // Check if it's an auto-generated ID (like "click_1" or "newfeature_click_1")
                const isAutoGenerated = new RegExp(`^(${cleanFeature}_)?${e.type}_\\d+$`).test(key);

                if (isAutoGenerated) {
                    const existingKey = LocatorMap.findBySelectorAndValue(e.selector, e.value);
                    if (existingKey) {
                        key = existingKey;
                    } else {
                        LocatorMap.register(key, e.selector, e.value);
                    }
                } else {
                    // User explicitly typed a meaningful name in the UI, use it.
                    LocatorMap.register(key, e.selector, e.value);
                }

                if (e.type === 'click') {
                    specBody += `
    await test.step('Click ${key}', async () => {
        const selector = LocatorMap.getPlaywrightSelector('${key}');
        await expect(page.locator(selector).first()).toBeVisible({ timeout: 15000 });
        await page.locator(selector).first().click();
    });`;
                } else if (e.type === 'input') {
                    specBody += `
    await test.step('Type into ${key}', async () => {
        const selector = LocatorMap.getPlaywrightSelector('${key}');
        const expectedValue = LocatorMap.getExpectedValue('${key}');
        const locator = page.locator(selector).first();
        await expect(locator).toBeVisible({ timeout: 15000 });
        try {
            await locator.fill(expectedValue);
            await expect(locator).toHaveValue(expectedValue, { timeout: 5000 });
        } catch (error) {
            await locator.click();
            await locator.pressSequentially(expectedValue);
        }
    });`;
                } else if (e.type === 'drag-select') {
                    specBody += `
    await test.step('Drag Select text inside ${key}', async () => {
        const selector = LocatorMap.getPlaywrightSelector('${key}');
        const locator = page.locator(selector).first();
        await expect(locator).toBeVisible({ timeout: 15000 });
        await locator.dblclick(); 
    });`;
                } else if (e.type === 'assert') {
                    const isInput = e.selector?.toLowerCase().includes('input') || e.selector?.toLowerCase().includes('textarea');
                    const assertMethod = isInput ? 'toHaveValue' : 'toHaveText';
                    specBody += `
    await test.step('Verify text in ${key}', async () => {
        const selector = LocatorMap.getPlaywrightSelector('${key}');
        const expectedValue = LocatorMap.getExpectedValue('${key}');
        const locator = page.locator(selector).first();
        await expect(locator).toBeVisible({ timeout: 15000 });
        await expect(locator).${assertMethod}(expectedValue, { timeout: 10000 });
    });`;
                }
            }
        }

        // Save updated map
        await LocatorMap.save(config.DataIdValuePath);


        const fullSpec = `${specImports}
// Load locators (ensure this runs before tests)
test.beforeAll(async () => {
    await LocatorMap.load('${config.DataIdValuePath.replace(/\\/g, '/')}');
});

test('${featureName}', async ({ page }) => {
${specBody}
});`;

        return {
            specContent: fullSpec,
            fixtureContent: "",
            pages: {},
            testData: {}
        };
    }
}
